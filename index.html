<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pLOCK - Professional Token Locking on PulseChain</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@3/tsparticles.bundle.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        :root {
            --pc-black: #0a0b0f;
            --pc-purple: #7a3cff;
            --pc-magenta: #ff00e0;
            --pc-cyan: #00e5ff;
            --pc-gray-1: #12131a;
            --pc-gray-2: #1b1c25;
            --pc-gray-3: #262838;
            --pc-white: #ffffff;
            --pc-text: #e2e8f0;
            --pc-text-muted: #94a3b8;
            --pc-border: #475569;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--pc-black);
            color: var(--pc-text);
            line-height: 1.6;
            overflow-x: hidden;
        }

        #particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
        }

        .container {
            max-width: 1440px;
            margin: 0 auto;
            padding: 0 20px;
            position: relative;
            z-index: 1;
        }

        .panel {
            background: linear-gradient(145deg, var(--pc-gray-1), var(--pc-gray-2));
            border: 1px solid var(--pc-border);
            clip-path: polygon(0 0, calc(100% - 12px) 0, 100% 12px, 100% 100%, 12px 100%, 0 calc(100% - 12px));
            box-shadow: 
                inset 2px 2px 4px rgba(255, 255, 255, 0.05),
                inset -2px -2px 4px rgba(0, 0, 0, 0.5),
                0 4px 16px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .btn {
            padding: 12px 24px;
            background: linear-gradient(145deg, var(--pc-gray-2), var(--pc-gray-3));
            border: 1px solid var(--pc-border);
            color: var(--pc-text);
            cursor: pointer;
            clip-path: polygon(0 0, calc(100% - 8px) 0, 100% 8px, 100% 100%, 8px 100%, 0 calc(100% - 8px));
            transition: all 0.2s ease;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 
                inset 1px 1px 2px rgba(255, 255, 255, 0.1),
                inset -1px -1px 2px rgba(0, 0, 0, 0.3);
        }

        .btn:hover {
            background: linear-gradient(145deg, var(--pc-gray-3), var(--pc-purple));
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 
                inset 2px 2px 4px rgba(0, 0, 0, 0.4),
                inset -1px -1px 2px rgba(255, 255, 255, 0.1);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary {
            background: linear-gradient(145deg, var(--pc-purple), var(--pc-magenta));
            color: var(--pc-white);
        }

        .btn-primary:hover {
            background: linear-gradient(145deg, var(--pc-magenta), var(--pc-cyan));
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid var(--pc-border);
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(45deg, var(--pc-purple), var(--pc-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .wallet-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .network-pill {
            padding: 4px 12px;
            background: var(--pc-gray-2);
            border: 1px solid var(--pc-border);
            border-radius: 16px;
            font-size: 12px;
            color: var(--pc-text-muted);
        }

        .network-pill.connected {
            background: linear-gradient(45deg, var(--pc-purple), var(--pc-cyan));
            color: var(--pc-white);
        }

        .hero {
            text-align: center;
            padding: 60px 0;
        }

        .hero h1 {
            font-size: clamp(36px, 5vw, 64px);
            font-weight: 700;
            margin-bottom: 16px;
            background: linear-gradient(45deg, var(--pc-purple), var(--pc-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero p {
            font-size: 18px;
            color: var(--pc-text-muted);
            margin-bottom: 8px;
        }

        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 24px;
            border-bottom: 1px solid var(--pc-border);
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: var(--pc-text-muted);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .tab:hover {
            color: var(--pc-text);
        }

        .tab.active {
            color: var(--pc-cyan);
            border-bottom-color: var(--pc-cyan);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 24px;
        }

        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--pc-text);
        }

        .form-input {
            width: 100%;
            padding: 16px;
            background: var(--pc-gray-1);
            border: 1px solid var(--pc-border);
            color: var(--pc-text);
            font-size: 16px;
            clip-path: polygon(0 0, calc(100% - 8px) 0, 100% 8px, 100% 100%, 8px 100%, 0 calc(100% - 8px));
        }

        .form-input:focus {
            outline: none;
            border-color: var(--pc-cyan);
            box-shadow: 0 0 0 2px rgba(0, 229, 255, 0.2);
        }

        .input-group {
            display: flex;
            gap: 8px;
        }

        .input-group .form-input {
            flex: 1;
        }

        .token-info {
            padding: 12px 16px;
            background: var(--pc-gray-2);
            border: 1px solid var(--pc-border);
            margin-top: 8px;
            font-size: 14px;
            color: var(--pc-text-muted);
            clip-path: polygon(0 0, calc(100% - 6px) 0, 100% 6px, 100% 100%, 6px 100%, 0 calc(100% - 6px));
        }

        .locks-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 24px;
        }

        .locks-table th,
        .locks-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--pc-border);
        }

        .locks-table th {
            background: var(--pc-gray-2);
            font-weight: 500;
            color: var(--pc-text);
        }

        .locks-table td {
            color: var(--pc-text-muted);
        }

        .status-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-badge.active {
            background: rgba(255, 165, 0, 0.2);
            color: #ffa500;
        }

        .status-badge.unlocked {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: var(--pc-gray-1);
            padding: 24px;
            max-width: 400px;
            width: 90%;
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 24px;
            background: var(--pc-gray-1);
            border: 1px solid var(--pc-border);
            z-index: 1001;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            clip-path: polygon(0 0, calc(100% - 8px) 0, 100% 8px, 100% 100%, 8px 100%, 0 calc(100% - 8px));
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            border-color: #22c55e;
        }

        .toast.error {
            border-color: #ef4444;
        }

        .demo-banner {
            background: linear-gradient(45deg, var(--pc-magenta), var(--pc-purple));
            color: var(--pc-white);
            text-align: center;
            padding: 12px;
            font-weight: 500;
        }

        .dev-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: var(--pc-gray-1);
            padding: 16px;
            border: 1px solid var(--pc-border);
            font-size: 12px;
            z-index: 1000;
            display: none;
        }

        .footer {
            margin-top: 80px;
            padding: 40px 0;
            border-top: 1px solid var(--pc-border);
            text-align: center;
            color: var(--pc-text-muted);
            font-size: 14px;
        }

        .countdown {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--pc-cyan);
        }

        .gas-estimate {
            background: var(--pc-gray-3);
            padding: 12px;
            margin: 16px 0;
            border-left: 3px solid var(--pc-cyan);
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 16px;
            }

            .wallet-info {
                width: 100%;
                justify-content: center;
            }

            .tabs {
                flex-wrap: wrap;
            }

            .input-group {
                flex-direction: column;
            }

            .locks-table {
                font-size: 14px;
            }

            .locks-table th,
            .locks-table td {
                padding: 8px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important;
            }
        }
    </style>
</head>
<body>
    <canvas id="particles"></canvas>

    <div id="demo-banner" class="demo-banner" style="display: none;">
        DEMO MODE - Contract not deployed
    </div>

    <div class="container">
        <header class="header">
            <div class="logo">pLOCK</div>
            <div class="wallet-info">
                <div id="network-pill" class="network-pill">Disconnected</div>
                <button id="connect-btn" class="btn btn-primary">Connect Wallet</button>
            </div>
        </header>

        <section class="hero">
            <h1>pLOCK</h1>
            <p>Professional token locking on PulseChain.</p>
            <p>Secure your tokens with time-based or linear vesting locks.</p>
        </section>

        <main>
            <div class="panel" style="padding: 32px;">
                <div class="tabs">
                    <button class="tab active" data-tab="token">Token Lock</button>
                    <button class="tab" data-tab="lp">LP Lock</button>
                    <button class="tab" data-tab="linear">Linear Vesting</button>
                </div>

                <div id="tab-token" class="tab-content active">
                    <div class="form-group">
                        <label class="form-label" for="token-address">Token Address</label>
                        <input type="text" id="token-address" class="form-input" placeholder="0x...">
                        <div id="token-info" class="token-info" style="display: none;"></div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="token-amount">Amount</label>
                        <div class="input-group">
                            <input type="text" id="token-amount" class="form-input" placeholder="0.0">
                            <button id="max-btn" class="btn">Max</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="unlock-time">Unlock Time</label>
                        <input type="datetime-local" id="unlock-time" class="form-input">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="beneficiary">Beneficiary</label>
                        <input type="text" id="beneficiary" class="form-input" placeholder="0x... (optional, defaults to your address)">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="notes">Notes (optional)</label>
                        <input type="text" id="notes" class="form-input" placeholder="Description for this lock">
                    </div>
                    <div id="gas-estimate-token" class="gas-estimate" style="display: none;"></div>
                    <button id="create-token-lock" class="btn btn-primary" style="width: 100%;">Create Token Lock</button>
                </div>

                <div id="tab-lp" class="tab-content">
                    <div class="form-group">
                        <label class="form-label" for="lp-address">LP Token Address</label>
                        <input type="text" id="lp-address" class="form-input" placeholder="0x...">
                        <div id="lp-info" class="token-info" style="display: none;"></div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="lp-amount">Amount</label>
                        <div class="input-group">
                            <input type="text" id="lp-amount" class="form-input" placeholder="0.0">
                            <button id="lp-max-btn" class="btn">Max</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="lp-unlock-time">Unlock Time</label>
                        <input type="datetime-local" id="lp-unlock-time" class="form-input">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="lp-beneficiary">Beneficiary</label>
                        <input type="text" id="lp-beneficiary" class="form-input" placeholder="0x... (optional, defaults to your address)">
                    </div>
                    <div id="gas-estimate-lp" class="gas-estimate" style="display: none;"></div>
                    <button id="create-lp-lock" class="btn btn-primary" style="width: 100%;">Create LP Lock</button>
                </div>

                <div id="tab-linear" class="tab-content">
                    <div class="form-group">
                        <label class="form-label" for="linear-token">Token Address</label>
                        <input type="text" id="linear-token" class="form-input" placeholder="0x...">
                        <div id="linear-token-info" class="token-info" style="display: none;"></div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="linear-amount">Amount</label>
                        <div class="input-group">
                            <input type="text" id="linear-amount" class="form-input" placeholder="0.0">
                            <button id="linear-max-btn" class="btn">Max</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="start-time">Start Time</label>
                        <input type="datetime-local" id="start-time" class="form-input">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="end-time">End Time</label>
                        <input type="datetime-local" id="end-time" class="form-input">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="linear-beneficiary">Beneficiary</label>
                        <input type="text" id="linear-beneficiary" class="form-input" placeholder="0x... (optional, defaults to your address)">
                    </div>
                    <div id="gas-estimate-linear" class="gas-estimate" style="display: none;"></div>
                    <button id="create-linear-lock" class="btn btn-primary" style="width: 100%;">Create Linear Lock</button>
                </div>
            </div>

            <section style="margin-top: 48px;">
                <h2 style="margin-bottom: 24px; font-size: 24px;">Your Locks</h2>
                <div class="panel" style="padding: 24px;">
                    <div style="margin-bottom: 16px; display: flex; gap: 12px; flex-wrap: wrap;">
                        <input type="text" id="search-locks" class="form-input" placeholder="Search by token..." style="max-width: 300px;">
                        <button id="refresh-locks" class="btn">Refresh</button>
                    </div>
                    <div style="overflow-x: auto;">
                        <table class="locks-table">
                            <thead>
                                <tr>
                                    <th>Lock ID</th>
                                    <th>Asset</th>
                                    <th>Amount</th>
                                    <th>Unlock Time</th>
                                    <th>Beneficiary</th>
                                    <th>Status</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="locks-table-body">
                                <tr>
                                    <td colspan="7" style="text-align: center; padding: 40px;">Connect wallet to view your locks</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
        </main>

        <footer class="footer">
            <p>pLOCK v1.0 | Professional token locking on PulseChain</p>
            <p style="margin-top: 8px;">Links • Documentation • Support</p>
        </footer>
    </div>

    <div id="network-modal" class="modal">
        <div class="modal-content panel" style="padding: 24px;">
            <h3 style="margin-bottom: 16px;">Switch to PulseChain</h3>
            <p style="margin-bottom: 24px; color: var(--pc-text-muted);">This app requires PulseChain network. Please switch to PulseChain to continue.</p>
            <button id="switch-network" class="btn btn-primary" style="width: 100%;">Switch Network</button>
        </div>
    </div>

    <div id="toast" class="toast panel"></div>

    <div id="dev-panel" class="dev-panel panel">
        <div>Provider: <span id="dev-provider">None</span></div>
        <div>Chain ID: <span id="dev-chain">None</span></div>
        <div>Last Error: <span id="dev-error">None</span></div>
    </div>

    <script>
        const CONFIG = {
            chainId: 369,
            rpcUrl: 'https://rpc.pulsechain.com',
            explorer: 'https://scan.pulsechain.com',
            lockerAddress: '0x0000000000000000000000000000000000000000' // replace with real address
        };

        const LOCKER_ABI = [
            "function lock(address token, uint256 amount, uint64 unlockTime, address beneficiary) returns (uint256 lockId)",
            "function lockLinear(address token, uint256 amount, uint64 start, uint64 end, address beneficiary) returns (uint256 lockId)",
            "function lockLP(address pair, uint256 amount, uint64 unlockTime, address beneficiary) returns (uint256 lockId)",
            "function getLock(uint256 lockId) view returns (address token, uint256 amount, uint64 unlockTime, address owner, address beneficiary, bool withdrawn)",
            "function withdraw(uint256 lockId)",
            "event Locked(uint256 indexed lockId, address indexed token, address indexed owner, uint256 amount, uint64 unlockTime, address beneficiary)",
            "event Withdrawn(uint256 indexed lockId, address indexed token, address indexed owner)"
        ];

        const ERC20_ABI = [
            "function name() view returns (string)",
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)",
            "function balanceOf(address) view returns (uint256)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function approve(address spender, uint256 amount) returns (bool)"
        ];

        const PAIR_ABI = [
            "function token0() view returns (address)",
            "function token1() view returns (address)",
            "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",
            "function name() view returns (string)",
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)",
            "function balanceOf(address) view returns (uint256)"
        ];

        const state = {
            provider: null,
            signer: null,
            account: null,
            chainId: null,
            demoMode: CONFIG.lockerAddress === '0x0000000000000000000000000000000000000000',
            locks: [],
            lockIdCounter: 1,
            tokenMetadata: new Map(),
            countdownIntervals: new Set()
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await initParticles();
            setupEventListeners();
            updateDevPanel();
            
            if (state.demoMode) {
                document.getElementById('demo-banner').style.display = 'block';
            }

            // Auto-connect if previously connected
            if (window.ethereum && window.ethereum.selectedAddress) {
                await connectWallet();
            }
        });

        // Initialize particles background
        async function initParticles() {
            try {
                await tsParticles.load("particles", {
                    fullScreen: false,
                    particles: {
                        number: { value: 50 },
                        color: { value: ["#7a3cff", "#ff00e0", "#00e5ff"] },
                        shape: { type: "circle" },
                        opacity: { value: 0.3 },
                        size: { value: 2 },
                        move: {
                            enable: true,
                            speed: 0.5,
                            direction: "none",
                            random: true,
                            straight: false,
                            outModes: "out"
                        },
                        links: {
                            enable: true,
                            distance: 150,
                            color: "#7a3cff",
                            opacity: 0.2,
                            width: 1
                        }
                    },
                    interactivity: {
                        detectsOn: "window",
                        events: {
                            onHover: { enable: true, mode: "repulse" },
                            resize: true
                        },
                        modes: {
                            repulse: { distance: 100, duration: 0.4 }
                        }
                    },
                    detectRetina: true
                });
            } catch (error) {
                console.error('Failed to initialize particles:', error);
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.dataset.tab;
                    switchTab(tabName);
                });
            });

            // Token address inputs
            document.getElementById('token-address').addEventListener('blur', () => readTokenInfo('token'));
            document.getElementById('lp-address').addEventListener('blur', () => readTokenInfo('lp'));
            document.getElementById('linear-token').addEventListener('blur', () => readTokenInfo('linear'));

            // Max buttons
            document.getElementById('max-btn').addEventListener('click', () => setMaxAmount('token'));
            document.getElementById('lp-max-btn').addEventListener('click', () => setMaxAmount('lp'));
            document.getElementById('linear-max-btn').addEventListener('click', () => setMaxAmount('linear'));

            // Create lock buttons
            document.getElementById('create-token-lock').addEventListener('click', createTokenLock);
            document.getElementById('create-lp-lock').addEventListener('click', createLPLock);
            document.getElementById('create-linear-lock').addEventListener('click', createLinearLock);

            // Refresh locks
            document.getElementById('refresh-locks').addEventListener('click', loadMyLocks);

            // Search functionality
            document.getElementById('search-locks').addEventListener('input', filterLocks);

            // Modal close on outside click
            document.getElementById('network-modal').addEventListener('click', (e) => {
                if (e.target.id === 'network-modal') {
                    e.target.classList.remove('show');
                }
            });

            // Initialize Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
            
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');
        }

        // Toast system
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast panel ${type}`;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 4000);
        }

        // Development panel
        function updateDevPanel() {
            if (new URLSearchParams(window.location.search).get('dev') === '1') {
                const devPanel = document.getElementById('dev-panel');
                devPanel.style.display = 'block';
                document.getElementById('dev-provider').textContent = state.provider ? 'Connected' : 'None';
                document.getElementById('dev-chain').textContent = state.chainId || 'None';
            }
        }

        // Wallet connection
        async function connectWallet() {
            try {
                if (typeof window.ethereum === 'undefined') {
                    showToast('Please install MetaMask or another Web3 wallet', 'error');
                    return;
                }

                state.provider = new ethers.BrowserProvider(window.ethereum);
                await state.provider.send('eth_requestAccounts', []);
                state.signer = await state.provider.getSigner();
                state.account = await state.signer.getAddress();
                
                const network = await state.provider.getNetwork();
                state.chainId = Number(network.chainId);

                updateWalletUI();
                await ensurePulseChain();
                updateDevPanel();
            } catch (error) {
                console.error('Connection failed:', error);
                showToast('Failed to connect wallet', 'error');
                document.getElementById('dev-error').textContent = error.message;
            }
        }

        async function disconnectWallet() {
            state.provider = null;
            state.signer = null;
            state.account = null;
            state.chainId = null;
            updateWalletUI();
            updateDevPanel();
        }

        function updateWalletUI() {
            const connectBtn = document.getElementById('connect-btn');
            const networkPill = document.getElementById('network-pill');

            if (state.account) {
                connectBtn.textContent = `${state.account.slice(0, 6)}...${state.account.slice(-4)}`;
                connectBtn.onclick = disconnectWallet;
                networkPill.textContent = state.chainId === CONFIG.chainId ? 'PulseChain' : `Chain ${state.chainId}`;
                networkPill.className = `network-pill ${state.chainId === CONFIG.chainId ? 'connected' : ''}`;
                loadMyLocks();
            } else {
                connectBtn.textContent = 'Connect Wallet';
                connectBtn.onclick = connectWallet;
                networkPill.textContent = 'Disconnected';
                networkPill.className = 'network-pill';
                renderLocksTable([]);
            }
        }

        async function ensurePulseChain() {
            if (state.chainId === CONFIG.chainId) return true;

            const modal = document.getElementById('network-modal');
            modal.classList.add('show');

            return new Promise((resolve) => {
                document.getElementById('switch-network').onclick = async () => {
                    try {
                        await state.provider.send('wallet_switchEthereumChain', [
                            { chainId: '0x171' }
                        ]);
                        modal.classList.remove('show');
                        const network = await state.provider.getNetwork();
                        state.chainId = Number(network.chainId);
                        updateWalletUI();
                        resolve(true);
                    } catch (error) {
                        if (error.code === 4902) {
                            try {
                                await state.provider.send('wallet_addEthereumChain', [{
                                    chainId: '0x171',
                                    chainName: 'PulseChain',
                                    nativeCurrency: {
                                        name: 'Pulse',
                                        symbol: 'PLS',
                                        decimals: 18
                                    },
                                    rpcUrls: [CONFIG.rpcUrl],
                                    blockExplorerUrls: [CONFIG.explorer]
                                }]);
                                modal.classList.remove('show');
                                const network = await state.provider.getNetwork();
                                state.chainId = Number(network.chainId);
                                updateWalletUI();
                                resolve(true);
                            } catch (addError) {
                                showToast('Failed to add PulseChain network', 'error');
                                resolve(false);
                            }
                        } else {
                            showToast('Failed to switch network', 'error');
                            resolve(false);
                        }
                    }
                };
            });
        }

        // Token metadata reading
        async function readTokenMeta(address, isLP = false) {
            try {
                if (!ethers.isAddress(address)) {
                    throw new Error('Invalid address');
                }

                const contract = new ethers.Contract(address, isLP ? PAIR_ABI : ERC20_ABI, state.provider);
                
                const [name, symbol, decimals] = await Promise.all([
                    contract.name(),
                    contract.symbol(),
                    contract.decimals()
                ]);

                let pairInfo = null;
                if (isLP) {
                    try {
                        const [token0Address, token1Address] = await Promise.all([
                            contract.token0(),
                            contract.token1()
                        ]);
                        
                        const token0Contract = new ethers.Contract(token0Address, ERC20_ABI, state.provider);
                        const token1Contract = new ethers.Contract(token1Address, ERC20_ABI, state.provider);
                        
                        const [token0Symbol, token1Symbol] = await Promise.all([
                            token0Contract.symbol(),
                            token1Contract.symbol()
                        ]);

                        pairInfo = { token0Symbol, token1Symbol };
                    } catch (error) {
                        console.warn('Failed to read pair info:', error);
                    }
                }

                const metadata = { name, symbol, decimals, isLP, pairInfo };
                state.tokenMetadata.set(address.toLowerCase(), metadata);
                return metadata;
            } catch (error) {
                console.error('Failed to read token metadata:', error);
                throw error;
            }
        }

        async function readTokenInfo(type) {
            const addressInput = document.getElementById(`${type === 'linear' ? 'linear-token' : type === 'lp' ? 'lp-address' : 'token-address'}`);
            const infoDiv = document.getElementById(`${type === 'linear' ? 'linear-token-info' : type === 'lp' ? 'lp-info' : 'token-info'}`);
            
            const address = addressInput.value.trim();
            if (!address) {
                infoDiv.style.display = 'none';
                return;
            }

            try {
                const metadata = await readTokenMeta(address, type === 'lp');
                
                let infoText = `${metadata.name} (${metadata.symbol}) - ${metadata.decimals} decimals`;
                if (metadata.isLP && metadata.pairInfo) {
                    infoText += ` | Pair: ${metadata.pairInfo.token0Symbol}/${metadata.pairInfo.token1Symbol}`;
                }
                
                infoDiv.textContent = infoText;
                infoDiv.style.display = 'block';
            } catch (error) {
                infoDiv.textContent = `Error: ${error.message}`;
                infoDiv.style.display = 'block';
            }
        }

        async function setMaxAmount(type) {
            if (!state.account || !state.provider) {
                showToast('Please connect wallet first', 'error');
                return;
            }

            const addressInput = document.getElementById(`${type === 'linear' ? 'linear-token' : type === 'lp' ? 'lp-address' : 'token-address'}`);
            const amountInput = document.getElementById(`${type === 'linear' ? 'linear-amount' : type === 'lp' ? 'lp-amount' : 'token-amount'}`);
            
            const address = addressInput.value.trim();
            if (!address || !ethers.isAddress(address)) {
                showToast('Please enter a valid token address first', 'error');
                return;
            }

            try {
                const contract = new ethers.Contract(address, ERC20_ABI, state.provider);
                const balance = await contract.balanceOf(state.account);
                const decimals = await contract.decimals();
                
                const formatted = ethers.formatUnits(balance, decimals);
                amountInput.value = formatted;
            } catch (error) {
                showToast('Failed to read balance', 'error');
            }
        }

        // Approval flow
        async function checkAndApprove(tokenAddress, amount, spender) {
            try {
                const contract = new ethers.Contract(tokenAddress, ERC20_ABI, state.signer);
                const decimals = await contract.decimals();
                const amountWei = ethers.parseUnits(amount, decimals);
                
                const allowance = await contract.allowance(state.account, spender);
                
                if (allowance < amountWei) {
                    showToast('Approval required...', 'info');
                    const tx = await contract.approve(spender, amountWei);
                    await tx.wait();
                    showToast('Approval successful', 'success');
                }
                return true;
            } catch (error) {
                showToast(`Approval failed: ${error.message}`, 'error');
                return false;
            }
        }

        // Gas estimation
        async function estimateGasForLock(type, params) {
            try {
                if (state.demoMode) return { gasEstimate: 150000n, gasCost: '0.001' };

                const contract = new ethers.Contract(CONFIG.lockerAddress, LOCKER_ABI, state.signer);
                let gasEstimate;

                switch (type) {
                    case 'token':
                        gasEstimate = await contract.lock.estimateGas(...params);
                        break;
                    case 'lp':
                        gasEstimate = await contract.lockLP.estimateGas(...params);
                        break;
                    case 'linear':
                        gasEstimate = await contract.lockLinear.estimateGas(...params);
                        break;
                }

                const gasPrice = await state.provider.getFeeData();
                const gasCost = ethers.formatEther(gasEstimate * gasPrice.gasPrice);

                return { gasEstimate, gasCost };
            } catch (error) {
                console.error('Gas estimation failed:', error);
                return { gasEstimate: 200000n, gasCost: '0.002' };
            }
        }

        function showGasEstimate(type, gasEstimate, gasCost) {
            const estimateDiv = document.getElementById(`gas-estimate-${type}`);
            estimateDiv.innerHTML = `
                <strong>Gas Estimate:</strong> ${gasEstimate.toLocaleString()} units<br>
                <strong>Estimated Cost:</strong> ~${gasCost} PLS
            `;
            estimateDiv.style.display = 'block';
        }

        // Lock creation functions
        async function createTokenLock() {
            if (!state.account) {
                showToast('Please connect wallet', 'error');
                return;
            }

            const address = document.getElementById('token-address').value.trim();
            const amount = document.getElementById('token-amount').value.trim();
            const unlockTime = document.getElementById('unlock-time').value;
            const beneficiary = document.getElementById('beneficiary').value.trim() || state.account;

            if (!validateInputs(address, amount, unlockTime)) return;

            try {
                const button = document.getElementById('create-token-lock');
                button.disabled = true;
                button.textContent = 'Creating...';

                const metadata = await readTokenMeta(address);
                const amountWei = ethers.parseUnits(amount, metadata.decimals);
                const unlockTimeUnix = Math.floor(new Date(unlockTime).getTime() / 1000);

                const params = [address, amountWei, unlockTimeUnix, beneficiary];
                const { gasEstimate, gasCost } = await estimateGasForLock('token', params);
                showGasEstimate('token', gasEstimate, gasCost);

                if (state.demoMode) {
                    // Demo mode simulation
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    const lockId = state.lockIdCounter++;
                    state.locks.push({
                        lockId,
                        token: address,
                        amount: amountWei,
                        unlockTime: unlockTimeUnix,
                        owner: state.account,
                        beneficiary,
                        withdrawn: false,
                        type: 'token',
                        txHash: '0xdemo...'
                    });
                    showToast('Demo lock created successfully', 'success');
                    renderLocksTable(state.locks);
                } else {
                    const approved = await checkAndApprove(address, amount, CONFIG.lockerAddress);
                    if (!approved) return;

                    const contract = new ethers.Contract(CONFIG.lockerAddress, LOCKER_ABI, state.signer);
                    const tx = await contract.lock(...params);
                    showToast(`Transaction sent: ${tx.hash.slice(0, 10)}...`, 'info');
                    
                    const receipt = await tx.wait();
                    showToast(`Lock created! View: ${CONFIG.explorer}/tx/${tx.hash}`, 'success');
                    loadMyLocks();
                }

                // Clear form
                clearForm('token');
            } catch (error) {
                showToast(`Failed to create lock: ${error.message}`, 'error');
                document.getElementById('dev-error').textContent = error.message;
            } finally {
                const button = document.getElementById('create-token-lock');
                button.disabled = false;
                button.textContent = 'Create Token Lock';
            }
        }

        async function createLPLock() {
            if (!state.account) {
                showToast('Please connect wallet', 'error');
                return;
            }

            const address = document.getElementById('lp-address').value.trim();
            const amount = document.getElementById('lp-amount').value.trim();
            const unlockTime = document.getElementById('lp-unlock-time').value;
            const beneficiary = document.getElementById('lp-beneficiary').value.trim() || state.account;

            if (!validateInputs(address, amount, unlockTime)) return;

            try {
                const button = document.getElementById('create-lp-lock');
                button.disabled = true;
                button.textContent = 'Creating...';

                const metadata = await readTokenMeta(address, true);
                const amountWei = ethers.parseUnits(amount, metadata.decimals);
                const unlockTimeUnix = Math.floor(new Date(unlockTime).getTime() / 1000);

                const params = [address, amountWei, unlockTimeUnix, beneficiary];
                const { gasEstimate, gasCost } = await estimateGasForLock('lp', params);
                showGasEstimate('lp', gasEstimate, gasCost);

                if (state.demoMode) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    const lockId = state.lockIdCounter++;
                    state.locks.push({
                        lockId,
                        token: address,
                        amount: amountWei,
                        unlockTime: unlockTimeUnix,
                        owner: state.account,
                        beneficiary,
                        withdrawn: false,
                        type: 'lp',
                        txHash: '0xdemo...'
                    });
                    showToast('Demo LP lock created successfully', 'success');
                    renderLocksTable(state.locks);
                } else {
                    const approved = await checkAndApprove(address, amount, CONFIG.lockerAddress);
                    if (!approved) return;

                    const contract = new ethers.Contract(CONFIG.lockerAddress, LOCKER_ABI, state.signer);
                    const tx = await contract.lockLP(...params);
                    showToast(`Transaction sent: ${tx.hash.slice(0, 10)}...`, 'info');
                    
                    const receipt = await tx.wait();
                    showToast(`LP Lock created! View: ${CONFIG.explorer}/tx/${tx.hash}`, 'success');
                    loadMyLocks();
                }

                clearForm('lp');
            } catch (error) {
                showToast(`Failed to create LP lock: ${error.message}`, 'error');
                document.getElementById('dev-error').textContent = error.message;
            } finally {
                const button = document.getElementById('create-lp-lock');
                button.disabled = false;
                button.textContent = 'Create LP Lock';
            }
        }

        async function createLinearLock() {
            if (!state.account) {
                showToast('Please connect wallet', 'error');
                return;
            }

            const address = document.getElementById('linear-token').value.trim();
            const amount = document.getElementById('linear-amount').value.trim();
            const startTime = document.getElementById('start-time').value;
            const endTime = document.getElementById('end-time').value;
            const beneficiary = document.getElementById('linear-beneficiary').value.trim() || state.account;

            if (!validateLinearInputs(address, amount, startTime, endTime)) return;

            try {
                const button = document.getElementById('create-linear-lock');
                button.disabled = true;
                button.textContent = 'Creating...';

                const metadata = await readTokenMeta(address);
                const amountWei = ethers.parseUnits(amount, metadata.decimals);
                const startTimeUnix = Math.floor(new Date(startTime).getTime() / 1000);
                const endTimeUnix = Math.floor(new Date(endTime).getTime() / 1000);

                const params = [address, amountWei, startTimeUnix, endTimeUnix, beneficiary];
                const { gasEstimate, gasCost } = await estimateGasForLock('linear', params);
                showGasEstimate('linear', gasEstimate, gasCost);

                if (state.demoMode) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    const lockId = state.lockIdCounter++;
                    state.locks.push({
                        lockId,
                        token: address,
                        amount: amountWei,
                        unlockTime: endTimeUnix,
                        startTime: startTimeUnix,
                        owner: state.account,
                        beneficiary,
                        withdrawn: false,
                        type: 'linear',
                        txHash: '0xdemo...'
                    });
                    showToast('Demo linear lock created successfully', 'success');
                    renderLocksTable(state.locks);
                } else {
                    const approved = await checkAndApprove(address, amount, CONFIG.lockerAddress);
                    if (!approved) return;

                    const contract = new ethers.Contract(CONFIG.lockerAddress, LOCKER_ABI, state.signer);
                    const tx = await contract.lockLinear(...params);
                    showToast(`Transaction sent: ${tx.hash.slice(0, 10)}...`, 'info');
                    
                    const receipt = await tx.wait();
                    showToast(`Linear Lock created! View: ${CONFIG.explorer}/tx/${tx.hash}`, 'success');
                    loadMyLocks();
                }

                clearForm('linear');
            } catch (error) {
                showToast(`Failed to create linear lock: ${error.message}`, 'error');
                document.getElementById('dev-error').textContent = error.message;
            } finally {
                const button = document.getElementById('create-linear-lock');
                button.disabled = false;
                button.textContent = 'Create Linear Lock';
            }
        }

        // Validation functions
        function validateInputs(address, amount, unlockTime) {
            if (!ethers.isAddress(address)) {
                showToast('Invalid token address', 'error');
                return false;
            }

            if (!amount || parseFloat(amount) <= 0) {
                showToast('Invalid amount', 'error');
                return false;
            }

            const unlockDate = new Date(unlockTime);
            if (unlockDate <= new Date()) {
                showToast('Unlock time must be in the future', 'error');
                return false;
            }

            return true;
        }

        function validateLinearInputs(address, amount, startTime, endTime) {
            if (!validateInputs(address, amount, endTime)) return false;

            const startDate = new Date(startTime);
            const endDate = new Date(endTime);

            if (startDate >= endDate) {
                showToast('End time must be after start time', 'error');
                return false;
            }

            if (startDate <= new Date()) {
                showToast('Start time must be in the future', 'error');
                return false;
            }

            return true;
        }

        function clearForm(type) {
            const fields = {
                token: ['token-address', 'token-amount', 'unlock-time', 'beneficiary', 'notes'],
                lp: ['lp-address', 'lp-amount', 'lp-unlock-time', 'lp-beneficiary'],
                linear: ['linear-token', 'linear-amount', 'start-time', 'end-time', 'linear-beneficiary']
            };

            fields[type].forEach(id => {
                document.getElementById(id).value = '';
            });

            document.getElementById(`${type === 'linear' ? 'linear-token-info' : type === 'lp' ? 'lp-info' : 'token-info'}`).style.display = 'none';
            document.getElementById(`gas-estimate-${type}`).style.display = 'none';
        }

        // Load user's locks
        async function loadMyLocks() {
            if (!state.account) return;

            try {
                if (state.demoMode) {
                    renderLocksTable(state.locks);
                    return;
                }

                const contract = new ethers.Contract(CONFIG.lockerAddress, LOCKER_ABI, state.provider);
                // In a real implementation, you would query events or have a method to get user's locks
                // For now, we'll show empty state for non-demo mode
                renderLocksTable([]);
            } catch (error) {
                console.error('Failed to load locks:', error);
                showToast('Failed to load locks', 'error');
            }
        }

        // Render locks table
        function renderLocksTable(locks) {
            const tbody = document.getElementById('locks-table-body');
            
            if (!locks.length) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 40px;">No locks found</td></tr>';
                return;
            }

            tbody.innerHTML = locks.map(lock => {
                const metadata = state.tokenMetadata.get(lock.token?.toLowerCase()) || { symbol: 'Unknown', decimals: 18 };
                const amount = ethers.formatUnits(lock.amount || 0, metadata.decimals);
                const unlockDate = new Date((lock.unlockTime || 0) * 1000);
                const now = new Date();
                const isUnlocked = now >= unlockDate;
                const canWithdraw = isUnlocked && lock.owner === state.account && !lock.withdrawn;

                return `
                    <tr>
                        <td>#${lock.lockId}</td>
                        <td>${metadata.symbol}</td>
                        <td>${parseFloat(amount).toLocaleString()}</td>
                        <td>
                            <div>${unlockDate.toLocaleDateString()} ${unlockDate.toLocaleTimeString()}</div>
                            <div class="countdown" data-unlock="${lock.unlockTime}">
                                ${isUnlocked ? 'Unlocked' : getTimeUntil(lock.unlockTime)}
                            </div>
                        </td>
                        <td>${lock.beneficiary === lock.owner ? 'Self' : `${lock.beneficiary.slice(0, 6)}...`}</td>
                        <td>
                            <span class="status-badge ${lock.withdrawn ? 'withdrawn' : isUnlocked ? 'unlocked' : 'active'}">
                                ${lock.withdrawn ? 'Withdrawn' : isUnlocked ? 'Unlocked' : 'Locked'}
                            </span>
                        </td>
                        <td>
                            ${canWithdraw ? `<button class="btn" onclick="withdrawLock(${lock.lockId})">Withdraw</button>` : ''}
                            <a href="${CONFIG.explorer}/tx/${lock.txHash}" target="_blank" class="btn" style="margin-left: 8px;">View Tx</a>
                        </td>
                    </tr>
                `;
            }).join('');

            // Start countdown timers
            startCountdownTimers();
        }

        function getTimeUntil(unlockTime) {
            const now = new Date();
            const unlock = new Date(unlockTime * 1000);
            const diff = unlock - now;

            if (diff <= 0) return 'Unlocked';

            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));

            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${minutes}m`;
            return `${minutes}m`;
        }

        function startCountdownTimers() {
            // Clear existing intervals
            state.countdownIntervals.forEach(interval => clearInterval(interval));
            state.countdownIntervals.clear();

            document.querySelectorAll('.countdown').forEach(element => {
                const unlockTime = parseInt(element.dataset.unlock);
                const interval = setInterval(() => {
                    const timeUntil = getTimeUntil(unlockTime);
                    element.textContent = timeUntil;
                    
                    if (timeUntil === 'Unlocked') {
                        clearInterval(interval);
                        state.countdownIntervals.delete(interval);
                        // Refresh the table to update withdraw buttons
                        loadMyLocks();
                    }
                }, 60000); // Update every minute

                state.countdownIntervals.add(interval);
            });
        }

        // Withdraw function
        async function withdrawLock(lockId) {
            if (!state.account) {
                showToast('Please connect wallet', 'error');
                return;
            }

            try {
                if (state.demoMode) {
                    const lock = state.locks.find(l => l.lockId === lockId);
                    if (lock) {
                        lock.withdrawn = true;
                        showToast('Demo withdrawal successful', 'success');
                        renderLocksTable(state.locks);
                    }
                    return;
                }

                const contract = new ethers.Contract(CONFIG.lockerAddress, LOCKER_ABI, state.signer);
                const tx = await contract.withdraw(lockId);
                showToast(`Withdrawal sent: ${tx.hash.slice(0, 10)}...`, 'info');
                
                await tx.wait();
                showToast(`Withdrawal successful! View: ${CONFIG.explorer}/tx/${tx.hash}`, 'success');
                loadMyLocks();
            } catch (error) {
                showToast(`Withdrawal failed: ${error.message}`, 'error');
            }
        }

        // Search and filter functionality
        function filterLocks() {
            const searchTerm = document.getElementById('search-locks').value.toLowerCase();
            if (!searchTerm) {
                renderLocksTable(state.locks);
                return;
            }

            const filtered = state.locks.filter(lock => {
                const metadata = state.tokenMetadata.get(lock.token?.toLowerCase()) || { symbol: 'Unknown' };
                return metadata.symbol.toLowerCase().includes(searchTerm) ||
                       lock.token.toLowerCase().includes(searchTerm);
            });

            renderLocksTable(filtered);
        }

        // Make functions globally available
        window.withdrawLock = withdrawLock;
    </script>
</body>
</html>
